{"meta":{"title":"YongMaple","subtitle":"我不生产代码，我只是代码的搬运工","description":"我不生产代码，我只是代码的搬运工","author":"YongMaple","url":"http://YongMaple.github.io"},"pages":[{"title":"","date":"2017-01-17T06:02:09.000Z","updated":"2017-01-17T06:02:09.000Z","comments":false,"path":"tags/index.html","permalink":"http://YongMaple.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-17T06:03:03.000Z","updated":"2017-01-17T06:03:03.000Z","comments":false,"path":"categories/index.html","permalink":"http://YongMaple.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"一小时入门Vue","slug":"一小时入门Vue","date":"2017-02-09T10:09:19.000Z","updated":"2017-03-19T06:12:09.000Z","comments":true,"path":"2017/02/09/一小时入门Vue/","link":"","permalink":"http://YongMaple.github.io/2017/02/09/一小时入门Vue/","excerpt":"","text":"引言 我是一个Vue的狂热粉丝，使用Vue半年左右时间，写这个文章主要是为了给自己做个系统的回顾，顺便给同样有需要的人参考一下，如果文中有不对的地方，欢迎留言指出。 我一直认为兴趣是最好的老师，在深入学习Vue之前，先跑起来一个简单的Vue的项目，先感受到Vue的魅力，再结合项目看文档会更加简单。 这会是一个简单（极其丑陋）的图书馆里系统，包含服务端和客户端。 跟着我动手写，光看不写学不好 准备工作再开始教程之前，我们先配置好环境 安装node，包括npm https://nodejs.org 安装vue-cli npm install -g vue-cli vue-cli 是vue.js的脚手架，用于自动生成vue.js模板工程的 安装好yarn（非必须，推荐使用） https://yarnpkg.com yarn是Facebook推出了一款开源JavaScript包管理器，比npm更可靠，且速度更快 项目创建首先执行vue init webpack-simple vue-curd，vue-curd是文件夹名，会自动创建，会有3个设置项，分别是项目名、描述和作者，一路回车就行了。由于是教学项目，不会使用有太多的依赖，所以这里我们使用webpack-simple模版来创建，在实际使用中可以使用webpack来创建 现在能看到vue-cli为我们建好了项目，后面文中所有的路径根目录都表示该项目目录 服务端搭建这里我们借助json-server这个工具快速搭建后台管理系统的服务端程序： 执行npm i json-server -g，Mac加上sudo 新建/server目录，用于防止服务端的文件 新建/server/db.json文件，作为服务端的数据库文件 在/server/db.json文件中写入以下数据： 123456789101112131415161718192021222324252627282930&#123; \"user\": [ &#123; \"id\": 10000, \"name\": \"Jimmy\", \"age\": 28, \"gender\": \"male\" &#125;, &#123; \"id\": 10001, \"name\": \"张三\", \"age\": 30, \"gender\": \"female\" &#125; ], \"book\": [ &#123; \"name\": \"前端从入门到精通\", \"price\": 9300, \"owner_id\": 10000, \"id\": 10000 &#125;, &#123; \"id\": 10001, \"name\": \"Java从入门到放弃\", \"price\": 1990, \"owner_id\": 10001 &#125; ]&#125; 最后在/server目录执行json-server db.json -w -p 3000 现在打开浏览器，访问网址http://localhost:3000，可以看到如下界面： 点击Routes下面的user会跳转到http://localhost:3000/user，可以看到我们之前在db.json中写入的user数组 我们在db.json文件中写入了标准的JSON格式数据，这个json里有一个user数组和一个book数组，这就告诉json-server，我们的数据库里有一个名为user的“表”和一个名为book的“表”，并且表里的数据为xxx，然后json-server就会启动服务器，并且以每个”表”为单位为我们注册一系列标准的RESTFull形式的API接口（路由），以user为例： [GET] /user #获取用户列表的接口 [GET] /user/:id #获取单个用户的接口 [POST] /user #新增用户的接口 [PUT] /user/:id #修改用户的接口 [DELETE] /user/:id #删除用户的接口 在获取列表的接口中也可以追加查询参数，来限定查询的结果，比如： 查询所有男性用户： /user?gender=male 查询年龄大于等于20并且小于等于29的用户：/user?age_gte=20&amp;age_lte=29 此外还有分页、排序、匹配、关系查询等查询方式，可以在这里查看更多 至此我们就拥有了一套强大的数据接口。 客户端搭建之前我们创建好了项目，但是还没下载依赖，现在根目录执行yarn install 安装好依赖后，执行yarn run dev，就能看到下图的欢迎页了 开始改造模版项目 删除/src/assets/下的图片 修改/src/main.js改名为app.js，个人习惯，可以不改，不改的话下两步也跳过 修改/webpack.config.js中第5行entry: &#39;./src/main.js&#39;,为entry: &#39;./src/app.js&#39;,，这个是入口文件。修改第8行publicPath: &#39;/dist/&#39;,为publicPath: &#39;/build/&#39;,，这个是编译后文件的存放路径 修改/index.html中第9行&lt;script src=&quot;/dist/build.js&quot;&gt;&lt;/script&gt;为&lt;script src=&quot;/build/build.js&quot;&gt;&lt;/script&gt; 将/src/App.vue中的内容删除，只留下下面这些12345678&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在Vue中&lt;template&gt;中写html，&lt;script&gt;中写脚本，&lt;style&gt;中写样式 添加用户页面/src/App.vue添加如下代码：123456789101112131415&lt;template&gt; &lt;div&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type=\"text\"&gt;&lt;br&gt; &lt;label&gt;年龄：&lt;/label&gt; &lt;input type=\"number\"&gt;&lt;br&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;select&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"male\"&gt;男&lt;/option&gt; &lt;option value=\"female\"&gt;女&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;button type=\"button\"&gt;添加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 可以看到添加页面的样子了，在&lt;template&gt;中有一点需要注意，每个组件只能有一个根节点，所以我们用&lt;div&gt;包起来 现在我们需要获取用户输入的数据，在Vue中可以采取双向绑定的方式来实现，我们先在&lt;script&gt;中添加如下代码：1234567891011export default &#123; data()&#123; return &#123; form:&#123; name:'', age:'', gender:'' &#125; &#125; &#125;&#125; 这里我们定义了一个form对象 data是个funciton，要设置的值是retrun回来的一个对象中的属性 下面将实现数据的绑定，改造&lt;template&gt;中代码为如下： 12345678910111213&lt;div&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" v-model=\"form.name\"&gt;&lt;br&gt; &lt;label&gt;年龄：&lt;/label&gt; &lt;input type=\"number\" v-model=\"form.age\"&gt;&lt;br&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;select v-model=\"form.gender\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"male\"&gt;男&lt;/option&gt; &lt;option value=\"female\"&gt;女&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;button type=\"button\"&gt;添加&lt;/button&gt;&lt;/div&gt; 通过v-model实现了数据的绑定 此时data中的值就是用户输入的值了，那么我们如何来确认呢？ 我们来给添加按钮绑定事件，通过点击添加按钮来弹框显示输入的内容，修改&lt;button type=&quot;button&quot;&gt;添加&lt;/button&gt;为&lt;button type=&quot;button&quot; @click=&quot;submit&quot;&gt;添加&lt;/button&gt; Vue中通过@click来监听点击事件 并在&lt;script&gt;中添加如下代码： 12345678export default &#123; data()&#123; ... &#125;, methods:&#123; submit()&#123; alert(`输入的姓名：$&#123; this.form.name &#125;，输入的年龄：$&#123; this.form.age &#125;，选择的性别：$&#123; this.form.gender &#125;`) &#125; &#125;&#125; 来试一下吧 现在，让我们把这条数据存到我们的数据库中吧，改写submit为如下：12345678910111213submit()&#123; fetch('http://localhost:3000/user',&#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(this.form) &#125;).then(()=&gt;&#123; alert(\"添加成功\") &#125;).catch(response =&gt;&#123; console.log(response); &#125;)&#125; 这里我们使用fetch来提交数据 Fetch被称为下一代Ajax技术,采用Promise方式来处理数据。是一种简洁明了的API，比XMLHttpRequest更加简单易用。 然后看一下http://localhost:3000/user，刚才添加的数据就在里面了 表单校验我们的现在可以在应用里添加用户了。但是还存在不小的问题： 用户可以输入任意长的名字 用户可以输入任意的年龄 用户可以不选择性别 盲目信任用户输入的数据，会给系统埋下不小的隐患。这回我们就来把这隐患扼杀在摇篮之中。 表单验证无非就是对用户输入的数据进行有效性、非空性验证，验证失败会在相应的地方显示错误信息，并阻止用户提交表单。 我们需要记录每一个字段当前的有效状态，有效时隐藏错误信息，无效时显示错误信息。 而这个有效/无效，可以在表单值改变的时候进行判断。 要做校验，在Vue中我们第一时间想到的肯定是computed、watch、get、set https://cn.vuejs.org/v2/guide/computed.html 思路大致上就是在form值发生改变时去同步的执行校验，如果校验失败，显示错误信息，有效则隐藏 让我们来试试，改造一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" v-model=\"form.name.value\"&gt;&lt;br&gt; &lt;label&gt;年龄：&lt;/label&gt; &lt;input type=\"number\" v-model=\"form.age.value\"&gt;&lt;br&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;select v-model=\"form.gender.value\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"male\"&gt;男&lt;/option&gt; &lt;option value=\"female\"&gt;女&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;button type=\"button\" @click=\"submit\"&gt;添加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; form:&#123; name:&#123; value:'', valid:false &#125;, age:&#123; value:'', valid:false &#125;, gender:&#123; value:'', valid:false &#125; &#125; &#125; &#125;, methods:&#123; submit()&#123; fetch('http://localhost:3000/user',&#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(this.form) &#125;).then(()=&gt;&#123; alert(\"添加成功\") &#125;).catch(response =&gt;&#123; console.log(response); &#125;) &#125; &#125;, computed:&#123; 'form.name.valid':function()&#123; return this.form.name.value.length &gt; 10 ? false : true &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 尝试了没有？这段代码是无效的，用watch也是无效的，这里就不写出来了 受ES5的限制，Vuejs不能检测到对象属性的变化这句话是错的，下面组件化的原因就改成使代码看着简洁点吧。所以百度出来的东西不一定是对的。。 那么，我们该如何来做呢？ 既然Vue只能检测到data的属性，那么我们可以使用组件化来实现，同时使我们的代码简洁，考虑到之后的修改页面也有类似的页面结构，我们将整个form封成组件 组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 新建/src/components/目录 在/src/components/下新建form.vue和formItem.vue 将之前的代码搬到formItem.vue，如下： 组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。 123456789101112131415161718192021222324252627282930&lt;template&gt;&lt;div&gt; &lt;label&gt;&#123;&#123;label&#125;&#125;：&lt;/label&gt; &lt;input v-if=\"type === 'String'\" type=\"text\" v-model=\"value\"&gt; &lt;input v-if=\"type === 'Number'\" type=\"number\" v-model=\"value\"&gt; &lt;select v-if=\"type === 'Select'\" v-model=\"val\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"male\"&gt;男&lt;/option&gt; &lt;option value=\"female\"&gt;女&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; label: &#123; type: String, default: '' &#125;, type: &#123; type: String, default: '' &#125;, value: &#123; type: null, default: '' &#125; &#125;&#125; 我们使用props接收父组件传递过来的参数，用v-if来判断该显示什么，像在data中使用一样用v-model来绑定数据 下面来写formItem.vue的父组件form.vue 12345678910111213141516171819&lt;template&gt;&lt;div&gt; &lt;form-item v-for=\"(item,key) in form\" :value=\"item.value\" :type=\"item.type\" :label=\"item.label\"&gt; &lt;/form-item&gt;&lt;/template&gt;&lt;script&gt;import formItem from './formItem.vue'export default &#123; props: &#123; form: Object &#125;, components: &#123; formItem &#125;&#125;&lt;/script&gt; 这里我将formItem.vue引入，并通过components在Vue中注册，这里我使用驼峰命名，在使用时直接通过&lt;form-item&gt;来使用 通过props来获取父组件App.vue传来的数据，然后使用v-for遍历对象的属性，通过:value、:type、:label将值传给子组件formItem.vue 最后修改一下App.vue 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt;&lt;div&gt; &lt;my-form :form=\"form\"&gt;&lt;/my-form&gt; &lt;button type=\"button\" @click=\"submit\"&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import form from './components/form.vue'export default &#123; data() &#123; return &#123; form: &#123; name: &#123; label: '姓名', value: '', type: 'String' &#125;, age: &#123; label: '年龄', value: '', type: 'Number' &#125;, gender: &#123; label: '性别', value: '', type: 'Select' &#125; &#125; &#125; &#125;, methods: &#123; ... &#125;, components: &#123; 'my-form': form &#125;&#125;&lt;/script&gt; 现在组件封装好了，但是数据还是没校验。我们先来设定一下规则，继续修改/src/App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt;&lt;div&gt; &lt;my-form :form=\"form\" :rules=\"rules\"&gt;&lt;/my-form&gt; &lt;button type=\"button\" @click=\"submit\"&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import form from './components/form.vue'export default &#123; data() &#123; return &#123; form: &#123; name: &#123; label: '姓名', value: '', type: 'String' &#125;, age: &#123; label: '年龄', value: '', type: 'Number' &#125;, gender: &#123; label: '性别', value: '', type: 'Select' &#125; &#125;, rules: &#123; //校验规则 name: [&#123; max: 10, min: 2, message: '名字必须在2-10个字符之间' &#125;, &#123; type: 'String', message: '名字格式不正确' &#125; ], age: [&#123; max: 100, min: 0, message: '年龄必须在0-100岁之间' &#125;, &#123; type: 'Number', message: '年龄只能是数字' &#125; ], gender: [&#123; value: ['male', 'female'], message: '请选择性别' &#125;] &#125;, validateState: true //表单校验状态 &#125; &#125;, methods: &#123; ... &#125;, components: &#123; 'my-form': form &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在components中，这次我们没有和form.vue中一样注册组件，而采取自定义名称的方式my-form 在这里，我们设定每个属性的校验规则都是一个数组，根据不同的情况可以显示不同的错误信息 max字符串最大长度或number最大值 min字符串最小长度或number最小值 type指定类型 value值只能是该数组中的值 message错误信息 然后通过:rules将规则传给form.vue，下面是form.vue的代码 123456789101112131415161718192021222324252627282930313233&lt;template&gt;&lt;div&gt; &lt;form-item v-for=\"(item,key) in form\" :field=\"item.field\" :value=\"item.value\" :type=\"item.type\" :rule=\"item.rule\" :label=\"item.label\"&gt; &lt;/form-item&gt;&lt;/template&gt;&lt;script&gt;import formItem from './formItem.vue'export default &#123; props: &#123; form: Object, rules: Object &#125;, created: function() &#123; let form = this.form let rules = this.rules for (let key in form) &#123; form[key].rule = rules[key] form[key].field = key form[key].validate = false &#125; this.form = form &#125;, components: &#123; formItem &#125;&#125;&lt;/script&gt; 每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会。例如created这个钩子在实例被创建之后被调用 生命周期： 在组件created中，我们将rules整合到form中，方便后面使用，并添加field(属性名)，validate（校验状态)字段 在&lt;form-item&gt;中，像之前一样将值传给formItem.vue 下面来看下formItem.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;template&gt;&lt;div&gt; &lt;label&gt;&#123;&#123;label&#125;&#125;：&lt;/label&gt; &lt;input v-if=\"type === 'String'\" type=\"text\" v-model=\"val\"&gt; &lt;input v-if=\"type === 'Number'\" type=\"number\" v-model=\"val\"&gt; &lt;select v-if=\"type === 'Select'\" v-model=\"val\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"male\"&gt;男&lt;/option&gt; &lt;option value=\"female\"&gt;女&lt;/option&gt; &lt;/select&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;br&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; message: '', val: '' &#125; &#125;, props: &#123; field: &#123; type: String &#125;, label: &#123; type: String, default: '' &#125;, type: &#123; type: String, default: '' &#125;, value: &#123; type: null, default: '' &#125;, rule: &#123; type: Array &#125;, &#125;, watch: &#123; val() &#123; let _this = this //试试不这么做会怎样，注释掉这行，将下面的_this都换成this，看看this指的是谁 let valid_msg = '' let validateState = true if (_this.rule) &#123; _this.rule.forEach(function(v, i) &#123; var keys = Object.keys(v) if (keys) &#123; keys.forEach(function(k) &#123; if (k != 'message') &#123; let valide = eval(k) if (!valide(_this.val, v[k])) &#123; valid_msg = v.message ? v.message : '系统异常' validateState = false &#125; &#125; &#125;) &#125; else &#123; validateState = false valid_msg = '系统异常' &#125; &#125;) &#125; _this.message = valid_msg &#125;, value()&#123; this.val = this.value &#125; &#125;&#125;function max(v, r) &#123; if (typeof v == 'string') return v.length &gt; r ? false : true else if (typeof v == 'number') return v &gt; r ? false : true&#125;function min(v, r) &#123; if (typeof v == 'string') return v.length &lt; r ? false : true else if (typeof v == 'number') return v &lt; r ? false : true&#125;function type(v, r) &#123; return typeof v == r.toLowerCase() ? true : false&#125;function value(v, r) &#123; return r.indexOf(v) != -1 ? true : false&#125;&lt;/script&gt; 尝试一下注释中说的，看看this指的是什么 到现在，我们已经能够实现校验了，但是问题又来了，现在App.vue中的form里面的属性值是没有的（动手试试），如form.name.value值一直是空的 prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。 那么我们如何将formItem.vue中的值传给App.vue，这里是最终形态的formItem.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;template&gt;&lt;div&gt; &lt;label&gt;&#123;&#123;label&#125;&#125;：&lt;/label&gt; &lt;input v-if=\"type === 'String'\" type=\"text\" v-model=\"val\"&gt; &lt;input v-if=\"type === 'Number'\" type=\"number\" v-model=\"val\"&gt; &lt;select v-if=\"type === 'Select'\" v-model=\"val\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"male\"&gt;男&lt;/option&gt; &lt;option value=\"female\"&gt;女&lt;/option&gt; &lt;/select&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;br&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; message: '', val: '' &#125; &#125;, props: &#123; field: &#123; type: String &#125;, label: &#123; type: String, default: '' &#125;, type: &#123; type: String, default: '' &#125;, value: &#123; type: null, default: '' &#125;, rule: &#123; type: Array &#125;, &#125;, watch: &#123; val() &#123; let _this = this //试试不这么做会怎样，注释掉这行，将下面的_this都换成this，看看this指的是谁 let valid_msg = '' let validateState = true if (_this.rule) &#123; _this.rule.forEach(function(v, i) &#123; var keys = Object.keys(v) if (keys) &#123; keys.forEach(function(k) &#123; if (k != 'message') &#123; let valide = eval(k) if (!valide(_this.val, v[k])) &#123; valid_msg = v.message ? v.message : '系统异常' validateState = false &#125; &#125; &#125;) &#125; else &#123; validateState = false valid_msg = '系统异常' &#125; &#125;) &#125; _this.message = valid_msg _this.$emit(\"transferValue\", [_this.field, _this.val,validateState]) &#125;, value()&#123; this.val = this.value &#125; &#125;&#125;function max(v, r) &#123; if (typeof v == 'string') return v.length &gt; r ? false : true else if (typeof v == 'number') return v &gt; r ? false : true&#125;function min(v, r) &#123; if (typeof v == 'string') return v.length &lt; r ? false : true else if (typeof v == 'number') return v &lt; r ? false : true&#125;function type(v, r) &#123; return typeof v == r.toLowerCase() ? true : false&#125;function value(v, r) &#123; return r.indexOf(v) != -1 ? true : false&#125;&lt;/script&gt; 我们使用自定义事件$emit将值传递出去，这里事件名是transferValue，在父组件中，只要监听transferValue事件就行了 下面是完整的form.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt;&lt;div&gt; &lt;form-item v-for=\"(item,key) in form\" v-on:transferValue=\"transferValue\" :field=\"item.field\" :value=\"item.value\" :type=\"item.type\" :rule=\"item.rule\" :label=\"item.label\"&gt; &lt;/form-item&gt;&lt;/template&gt;&lt;script&gt;import formItem from './formItem.vue'export default &#123; props: &#123; form: Object, rules: Object &#125;, created: function() &#123; let form = this.form let rules = this.rules for (let key in form) &#123; form[key].rule = rules[key] form[key].field = key form[key].validate = false &#125; this.form = form &#125;, methods: &#123; transferValue(args) &#123; let [field, value, validate] = [...args] this.form[field].validate = validate let flag = true for (var key in this.form) &#123; if (!this.form[key].validate) flag = false &#125; this.$emit('changeValue', [field, value, flag]) &#125; &#125;, components: &#123; formItem &#125;&#125;&lt;/script&gt; 我们看一下&lt;form-item&gt;中，v-on:transferValue=&quot;transferValue&quot;就是上面说的监听事件，后面的transferValue是methods中的方法名 下面是完整的App.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt;&lt;div&gt; &lt;my-form :form=\"form\" :rules=\"rules\" v-on:changeValue=\"changeValue\"&gt;&lt;/my-form&gt; &lt;button type=\"button\" @click=\"submit\"&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import form from './components/form.vue'export default &#123; data() &#123; return &#123; form: &#123; name: &#123; label: '姓名', value: '', type: 'String' &#125;, age: &#123; label: '年龄', value: '', type: 'Number' &#125;, gender: &#123; label: '性别', value: '', type: 'Select' &#125; &#125;, rules: &#123; //校验规则 name: [&#123; max: 10, min: 2, message: '名字必须在2-10个字符之间' &#125;, &#123; type: 'String', message: '名字格式不正确' &#125; ], age: [&#123; max: 100, min: 0, message: '年龄必须在0-100岁之间' &#125;, &#123; type: 'Number', message: '年龄只能是数字' &#125; ], gender: [&#123; value: ['male', 'female'], message: '请选择性别' &#125;] &#125;, validateState: true //表单校验状态 &#125; &#125;, methods: &#123; changeValue(args) &#123; let [field, value, validateState] = [...args] this.form[field].value = value this.validateState = validateState &#125;, submit() &#123; if(this.validateState)&#123; let form = this.form let parms = &#123; name: form.name.value, age: form.age.value, gender: form.gender.value &#125; fetch('http://localhost:3000/user', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(parms) &#125;).then(() =&gt; &#123; alert(\"添加成功\") &#125;).catch(response =&gt; &#123; console.log(response); &#125;) &#125;else&#123; alert('数据错误，请修改后提交') &#125; &#125; &#125;, components: &#123; 'my-form': form &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 现在，来回顾下流程： formItem.vue中watch了val 在val发生变化时，遍历对应的rule 当有不匹配规则时，将错误信息改成rule中对应的错误信息 将属性名、输入值、校验状态通过$emit发送给form.vue form.vue中将通过transferValue收到传递的参数 将form中对应属性名的属性校验状态修改为传递来的值 遍历form中所有属性的校验状态，最后将属性名、输入值、整个form的校验状态通过changeValue传给App.vue App.vue中通过changeValue接受参数，将form对应属性的值更新，并修改整个form的校验状态validateState 最后在submit中判断validateState，来判断是否允许提交 现在我们有了一个完整的添加页面了 加入路由及列表页面现在，我们需要做一个列表页面来展示数据库中的数据，那么，该写在哪呢？添加页面我们目前是直接写在App.vue里的 之前我们只使用了json-server的POST请求，现在我们还要用到GET请求，所以对我们所有的request进行封装 新建/src/services/目录并新建request.js 将下面的代码复制到request.js中 12345678910111213141516171819202122232425262728export default function request(method, url, body) &#123; method = method.toUpperCase(); if (method === 'GET') &#123; body = undefined; &#125; else &#123; body = body &amp;&amp; JSON.stringify(body); &#125; return fetch(url, &#123; method, headers: &#123; 'Content-Type': 'application/json', &#125;, body &#125;) .then((res) =&gt; &#123; if (res.status &gt;= 200 &amp;&amp; res.status &lt; 300) &#123; return res.json(); &#125; else &#123; alert('系统异常') &#125; &#125;);&#125;export const get = url =&gt; request('GET', url);export const post = (url, body) =&gt; request('POST', url, body);export const put = (url, body) =&gt; request('PUT', url, body);export const del = (url, body) =&gt; request('DELETE', url, body); 新建目录/src/views 新建文件/src/views/list.vue 新建文件/src/views/add.vue 将/src/App.vue中的代码复制到/src/views/add.vue 修改add.vue如下： 1234567891011121314151617181920212223242526&lt;template&gt;...&lt;/template&gt;&lt;script&gt;import form from '../components/form.vue' //注意修改路径为../import &#123; post &#125; from '../services/request.js'export default &#123; data() &#123; ... &#125;, methods: &#123; changeValue(args) &#123; ... &#125;, submit() &#123; if(this.validateState)&#123; let form = this.form let parms = &#123; ... &#125; post('http://localhost:3000/user',parms).then(() =&gt; &#123; alert(\"添加成功\") &#125;) &#125;else&#123; ... &#125; &#125; &#125;, components: &#123; ... &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 注意： 修改路径./为../ 将下面的代码复制到list.vue 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt;&lt;div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;用户ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"(item,index) in list\"&gt; &lt;td&gt;&#123;&#123;index+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.gender&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; get &#125; from '../services/request.js'export default &#123; data() &#123; return &#123; list: [] &#125; &#125;, created() &#123; get('http://localhost:3000/user').then(response =&gt; &#123; this.list = response &#125;) &#125;&#125;&lt;/script&gt; 现在，我们拥有了一个list页面，一个add页面。但是，我们并不能看到，为什么？回顾一下： 我们在/webpack.config.js中配置了入口是./src/app.js 然后我们在/app.js引入了/App.vue 然后咧？list.vue和add.vue怎么办？ 这里我们引入vue-router路由 用 Vue.js + vue-router 创建单页应用，是非常简单的。使用 Vue.js 时，我们就已经把组件组合成一个应用了，当你要把 vue-router 加进来，只需要配置组件和路由映射，然后告诉 vue-router 在哪里渲染它们 终端在项目路径下执行npm install vue-router -S vue-router添加到了package.json的dependencies中 devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。 新建/src/router目录，并在目录中新建index.js，写入以下代码： 12345678910111213141516171819202122232425262728import Vue from 'vue'import Router from 'vue-router'import List from '../views/list.vue'import Add from '../views/add.vue'Vue.use(Router)let router = new Router(&#123; mode: 'history', base: __dirname, routes: [&#123; name: 'list', //名称 path: '/', //路径 component: List //组件 &#125;, &#123; name: 'add', path: '/add', component: Add &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; //在每次路由跳转之前都会先执行其中的代码，再通过调用next()执行后续操作 next()&#125;)router.afterEach((to, from) =&gt; &#123;&#125;) //每次路由跳转之后都会执行其中的代码export default router 这里我们给列表页指定路径为/，添加页为/add，那么，我们在浏览器中输入http://localhost:8080时，默认的就是列表页，http://localhost:8080/add时，就是添加页 修改/src/app.js 123456789import Vue from 'vue'import App from './App.vue'import router from './router'new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) 将/src/App.vue修改为如下： 123456&lt;template&gt; &lt;div id=\"app\"&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view class=\"view\"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 路由匹配到的组件将在&lt;router-view&gt;中渲染 好了，试试吧，现在可以看到效果了 但是我们现在只能通过在浏览器输入地址来切换页面，这可不行，我们来加个按钮 在list.vue中添加如下： 123456789101112&lt;template&gt;&lt;div&gt; &lt;table&gt; ... &lt;/table&gt; &lt;router-link to=\"/add\"&gt;添加用户&lt;/router-link&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; ...&lt;/script&gt; 在add.vue中添加如下：12345678910&lt;template&gt;&lt;div&gt; &lt;my-form :form=\"form\" :rules=\"rules\" v-on:changeValue=\"changeValue\"&gt;&lt;/my-form&gt; &lt;button type=\"button\" @click=\"submit\"&gt;提交&lt;/button&gt; &lt;router-link to=\"/\"&gt;返回列表&lt;/router-link&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;...&lt;/script&gt; &lt;router-link&gt;中to写的是要跳转的路径 好了，添加和列表页完成了，下面来做编辑页面 编辑页面和路由传参 新建src/views/edit.vue，并将add.vue中的代码复制过来 在/src/router/index.js中添加edit组件的路由映射，代码如下 12345678910111213141516171819202122232425262728293031323334import Vue from 'vue'import Router from 'vue-router'import List from '../views/list.vue'import Add from '../views/add.vue'import Edit from '../views/edit.vue'Vue.use(Router)let router = new Router(&#123; mode: 'history', base: __dirname, routes: [&#123; name: 'list', //名称 path: '/', //路径 component: List //组件 &#125;, &#123; name: 'add', path: '/add', component: Add &#125;, &#123; name: 'edit', path: '/edit/:id', component: Edit &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; //在每次路由跳转之前都会先执行其中的代码，再通过调用next()执行后续操作 next()&#125;)router.afterEach((to, from) =&gt; &#123;&#125;) //每次路由跳转之后都会执行其中的代码export default router :id是什么？下面讲到 在/src/views/list.vue中添加如下编辑按钮，代码如下 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt;&lt;div&gt; &lt;table&gt; &lt;thead&gt; ... &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"(item,index) in list\"&gt; &lt;td&gt;&#123;&#123;index+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.gender&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a @click=\"toEdit(item.id)\"&gt;编辑&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;router-link to=\"/add\"&gt;添加用户&lt;/router-link&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; get &#125; from '../services/request.js'export default &#123; data() &#123; ... &#125;, created() &#123; ... &#125;, methods: &#123; toEdit(id) &#123; this.$router.push(&#123; name: 'edit', params: &#123; id: id &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt; 这里我们使用了router的另一种跳转方式，编程式路由 其中name就是我们在/src/router/index.js中设置的name，还记得吗？ 12345&#123; name: 'edit', path: '/edit/:id', component: Edit&#125; params就是我们在路由跳转时传递给edit.vue页面的参数，id对应的就是上面path: &#39;/edit/:id&#39;,中的id 下面来处理编辑页面，代码修改如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;template&gt;&lt;div&gt; &lt;my-form :form=\"form\" :rules=\"rules\" v-on:changeValue=\"changeValue\"&gt;&lt;/my-form&gt; &lt;button type=\"button\" @click=\"submit\"&gt;提交&lt;/button&gt; &lt;router-link to=\"/\"&gt;返回列表&lt;/router-link&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import form from '../components/form.vue'import &#123; get , put &#125; from '../services/request.js'export default &#123; data() &#123; return &#123; form: &#123; name: &#123; label: '姓名', value: '', type: 'String' &#125;, age: &#123; label: '年龄', value: '', type: 'Number' &#125;, gender: &#123; label: '性别', value: '', type: 'Select' &#125; &#125;, rules: &#123; //校验规则 name: [&#123; max: 10, min: 2, message: '名字必须在2-10个字符之间' &#125;, &#123; type: 'String', message: '名字格式不正确' &#125; ], age: [&#123; max: 100, min: 0, message: '年龄必须在0-100岁之间' &#125;, &#123; type: 'Number', message: '年龄只能是数字' &#125; ], gender: [&#123; value: ['male', 'female'], message: '请选择性别' &#125;] &#125;, validateState: true, //表单校验状态 id:'' &#125; &#125;, created()&#123; this.id = this.$route.params.id //路由中传递过来的参数 get(`http://localhost:3000/user/$&#123;this.id&#125;`).then(response =&gt;&#123; for (let key in response) &#123; if(key != 'id')&#123; this.form[key].value = response[key] &#125; &#125; console.log(this.form); &#125;) &#125;, methods: &#123; changeValue(args) &#123; let [field, value, validateState] = [...args] this.form[field].value = value this.validateState = validateState &#125;, submit() &#123; if(this.validateState)&#123; let form = this.form let parms = &#123; name: form.name.value, age: form.age.value, gender: form.gender.value &#125; put(`http://localhost:3000/user/$&#123;this.id&#125;`,parms).then(() =&gt; &#123; alert(\"修改成功\") &#125;) &#125;else&#123; alert('数据错误，请修改后提交') &#125; &#125; &#125;, components: &#123; 'my-form': form &#125;&#125;&lt;/script&gt; 编辑页面和添加的区别在于进入页面时需要通过this.$route.params.id获取列表页传过来的id，然后通过id查询出该用户的信息，并填充在form中 这里我们还修改了import { get , put } from &#39;../services/request.js&#39;和submit()方法，注意不要漏改了，或者直接整个复制过去 好了，现在编辑页面也完成了 删除现在添加删除功能，有了前面的编辑，删除相信你不看我的代码也能写了，自己先试试吧 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt;&lt;div&gt; &lt;table&gt; &lt;thead&gt; ... &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"(item,index) in list\"&gt; &lt;td&gt;&#123;&#123;index+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.gender&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a @click=\"toEdit(item.id)\"&gt;编辑&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a @click=\"toDel(item.id)\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;router-link to=\"/add\"&gt;添加用户&lt;/router-link&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; get , del &#125; from '../services/request.js'export default &#123; data() &#123; ... &#125;, created() &#123; ... &#125;, methods: &#123; toEdit(id) &#123; ... &#125;, toDel(id)&#123; del(`http://localhost:3000/user/$&#123;id&#125;`).then(()=&gt;&#123; get('http://localhost:3000/user').then(response =&gt; &#123; this.list = response &#125;) alert('删除成功') &#125;) &#125; &#125;&#125;&lt;/script&gt; 现在我们完成用户的增删改查所有功能了，但是现在所有人都可以直接操作数据，这肯定不行，我们还需要加入登陆验证才行 登陆和状态管理(Vuex)未完待续","categories":[{"name":"教程","slug":"教程","permalink":"http://YongMaple.github.io/categories/教程/"},{"name":"Vue","slug":"教程/Vue","permalink":"http://YongMaple.github.io/categories/教程/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://YongMaple.github.io/tags/Vue/"}]},{"title":"Mongoose入门","slug":"Mongoose入门","date":"2017-02-07T09:05:05.000Z","updated":"2017-02-09T10:10:50.000Z","comments":true,"path":"2017/02/07/Mongoose入门/","link":"","permalink":"http://YongMaple.github.io/2017/02/07/Mongoose入门/","excerpt":"","text":"准备工作安装Node.js和MongoDB安装Node.js，地址：https://nodejs.org/安装MongoDB，地址：https://www.mongodb.com/ 启动MongoDBcd到mongodb下的bin文件夹，执行./mongod即可，但是我们执行后会出如下错误这里提示我们没有/data/db文件夹，需要我们自己来新建，这里我在mongodb-3.4.0下新建了mydata文件夹，并通过./mongod --dbpath ../mydata启动了MongoDB，--datapath是用来指定路径的那么让我们来体验一下mongodb吧，首先要新建一个tab，然后同样cd到bin目录下，执行./mongo然后我们切回之前的tab可以看到有一个新的连接 MongoDB基础命令 因为我们后期基本不会在shell里来操作，所有这里只讲几个基本的，下面的test可以随意命名，是集合名 db.test.insert()在集合中插入一条数据 db.test.find()查找集合中所有的，可以加入参数，如db.test.find({name:&quot;Jimmy&quot;}) db.test.remove({})删除集合中所有元素，{}必须写 show collections查看所有集合 mongoose的安装新建一个文件夹，通过npm init初始化，通过npm install mongoose --save安装mongoose 通过mongoose连接数据库新建一个js文件，复制以下代码并在shell运行node xxx.js，xxx为你的文件名12var mongoose = require(\"mongoose\");mongoose.connect(\"mongodb://localhost/test\") 运行之后在之前的mongod的tab中看到有了一个新的连接 Mongoose入门创建类Class的方式1var User = mongoose.model(\"User\",userSchema) &quot;User&quot;表示类名，在数据库中集合名会自动转化为小写加susers userSchema定义了对象的原型 · 举个栗子12345678910111213141516var mongoose = require(\"mongoose\");mongoose.connect(\"mongodb://localhost/test\")userSchema = new mongoose.Schema(&#123; //如果只需要指定类型的话可以直接写，如果需要其他条件，需要写成对象的形式 name:String, qq:&#123; type:String, default:\"740534248\" //默认 &#125;&#125;);const User = mongoose.model(\"User\",userSchema)const user = new User(&#123; name:\"YongMaple\"&#125;)user.save() 指定对象的属性类型 javascript内置类型 String Number Boolean Date Array node.js内置类型 Buffer mongoose特有类型 Mixed ObjectId 举个栗子1234567891011121314151617181920212223242526272829var mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const ObjSchema = new mongoose.Schema(&#123; str : String, num : Number, bool : Boolean, arr : Array, //[] arr2 : [Date], arr3 : [String], time : Date, buf : Buffer, mxo : mongoose.Schema.Types.Mixed, //&#123;&#125; 混合数据类型 oid : mongoose.Schema.Types.ObjectId //唯一的&#125;)const obj = mongoose.model(\"obj\",ObjSchema)const o = new obj(&#123; time : new Date( 42342342344), //内部自动转化为Date类型，转化失败将报错 arr3 : [1234,\"jimmy\",new Date], //内部自动转化 String buf : new Buffer([22,33,44]), oid : mongoose.Types.ObjectId()&#125;)o.save(function(err)&#123; console.log(err);&#125;) 自定义类型使用自定义类型，需要： 继承mongoose.SchemaType(key,options,typeName) 重写cast(value)方法 加入mongoose.Schema.Types 举个栗子创建User.js文件1234567891011121314151617181920212223242526272829303132333435363738394041const mongoose = require(\"mongoose\")//es5版// function User(key,options)&#123;// mongoose.SchemaType.call(this,key,options,\"User\")// &#125;//// User.prototype = Object.create(mongoose.SchemaType.prototype)//// User.prototype.cast = function(val)&#123;// if(val.loginname &amp;&amp; val.password &amp;&amp; val.loginname.length &gt; 3)&#123;// return &#123;// loginname : val.loginname,// password : val.password// &#125;// &#125;else&#123;// throw new Error(\"user has error!\")// &#125;// &#125;//// mongoose.Schema.Types.User = User;//// module.exports = User;//es6版class User extends mongoose.SchemaType&#123; constructor(key,opts)&#123; super(key,opts,\"User\") &#125; cast(val)&#123; if(val.loginname &amp;&amp; val.password &amp;&amp; val.loginname.length &gt; 3)&#123; return &#123; loginname : val.loginname, password : val.password &#125; &#125;else&#123; throw new Error(\"user has error!\") &#125; &#125;&#125; 再创建一个demo.js文件来使用上面的User.js1234567891011121314151617181920const mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const User = require(\"./User\")const People = mongoose.model(\"People\",new mongoose.Schema(&#123; user:User&#125;))const o = new People(&#123; user:&#123; loginname:\"jimmy\", password:\"123456\" &#125;&#125;)o.save(function callback(err,result)&#123; console.log(err);&#125;) 所有类型都具有的配置 强制不得为空（验证器） required:true 设置属性默认值 default:”qq740534248” 是否包括在查询结果中 select:false getter 和 setter 拦截器 get:v =&gt; v set:v =&gt; v 举个栗子12345678910111213141516171819202122232425262728293031323334353637383940const mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const Obj = mongoose.model(\"Obj\",new mongoose.Schema(&#123; str:&#123; type:String, default:\"YongMaple\", get(v)&#123; return `my name is $&#123;v&#125;` &#125;, set(v)&#123; return 123+v &#125; &#125;, loginname:&#123; type:String, required:true &#125;, str2:&#123; type:String, select:false &#125;&#125;))const o = new Obj(&#123; str:\"Jimmy\", str2:\"111111\", loginname:\"333333\"&#125;)console.log(o.str); //my name is 123Jimmyo.save(function(err)&#123; console.log(err); Obj.findOne(&#123;&#125;,function(err,result)&#123; console.log(result); //&#123; _id: 58993a84a184201ce8ebf5f5, __v: 0, str: '123Jimmy' &#125; &#125;)&#125;) 对属性的验证和转换验证 枚举 enum:Array 正则表达式验证 match 限制字符串最大和最小长度 maxlength &amp; minlength Number和Date的最大最小值 max &amp; min 转换 字母大小写转化 lowercase &amp; uppercase 去除字符串前后空白字符 trim:true/false 举个栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const mongoose =require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const baseDateNum = Date.now()const Obj = mongoose.model(\"Obj\",new mongoose.Schema(&#123; str:&#123; type:String, enum:[\"aaa\",\"bbb\"] &#125;, qq:&#123; type:String, match:/^\\d*$/, maxlength:20, minlength:5 &#125;, lowerstr:&#123; type:String, lowercase:true &#125;, upperstr:&#123; type:String, uppercase:true &#125;, trimstr:&#123; type:String, trim:true &#125;, num:&#123; type:Number, min:6, max:20 &#125;, date:&#123; type:Date, min:new Date(baseDateNum - 1000), max:new Date(baseDateNum + 2000) &#125;&#125;))const o = new Obj(&#123; str:\"bbb\", qq:\"740534248\", lowerstr:\"aaaAAAA\", upperstr:\"bbbBBBB\", trimstr:\" aaa aaff\", num:6, date:new Date(baseDateNum+1000)&#125;)console.log(o);const err = o.validateSync() //同步校验，后面会讲console.log(err); 自定义验证器有三种方式来自定义验证器 validate:{ validator:Function } Class.schema.path(xxx).validate(fn) //xxx 表示要获取的属性名，然后对其验证 validator(v,[callback])同步验证器，加入第二个参数callback变为异步验证器举个栗子 123456789101112131415161718192021222324252627const mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const User = mongoose.model(\"User\",new mongoose.Schema(&#123; name:&#123; type:String, // validate:&#123; //同步验证器，也可以是数组形式，同时多个验证器 // validator(value)&#123; // return value.length &lt;= 9 // &#125; // &#125; &#125;&#125;))User.schema.path(\"name\").validate(function(v)&#123; return v.length &lt;= 9&#125;)User.schema.path(\"name\").validate(function(v)&#123; //可以加入多个 return v.length &gt; 3&#125;)const u = new User(&#123; name:\"1234\"&#125;)const err = u.validateSync()console.log(err); 再举个异步的栗子1234567891011121314151617181920212223const mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const User = mongoose.model(\"User\",new mongoose.Schema(&#123; loginname:&#123; type:String, validate:&#123; validator(value,cb)&#123; User.findOne(&#123;loginname:value&#125;,function(err,result)&#123; cb(!result) &#125;) &#125; &#125; &#125;&#125;))var user = new User(&#123; loginname:\"hahahaha\"&#125;)user.save(function(err)&#123; console.log(err); //运行2遍，第二遍会抛出异常&#125;) 获取错误信息 doc.validate( error =&gt; error ) 异步获得错误信息 error = doc.validateSync() 获取同步错误信息 doc.save( error =&gt; error ) 回调获得错误信息 promise = doc.save() promise方式获得错误信息 Class.update( query , update , { runValidators:true } , callback)举个栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445const mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const User = mongoose.model(\"User\",new mongoose.Schema(&#123; loginname:&#123; type:String, required:true, validate:&#123; validator(value,cb)&#123; setTimeout(function() &#123; cb(false) &#125;) &#125; &#125; &#125;&#125;))const u = new User(&#123; loginname:\"aaa11\"&#125;)//1 只能获得同步const err = u.validateSync()console.log(err);// 2 同步异步都能// u.validate(function(err)&#123;// console.log(err);// &#125;)//3 同步异步都能 有可能是底层传上来的错误// u.save(function(err)&#123;// console.log(err);// &#125;)//4 同步异步都能 有可能是底层传上来的错误// const promise = u.save()// promise.catch(err =&gt; console.log(err))//5 同步异步都能 有可能是底层传上来的错误// User.update(&#123;&#125;,&#123;loginname:\"123aaa\"&#125;,&#123;runValidators:true&#125;,function(err)&#123;// console.log(err);// &#125;) 错误信息 err.errors 错误集合 err.errors.qq 得到qq属性值的错误信息 { path , value , message } = err.errors.qq举个栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445const mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const User = mongoose.model(\"User\",new mongoose.Schema(&#123; loginname:&#123; type:String, required:[true,\"必须输入 &#123;PATH&#125; - &#123;VALUE&#125;\"], //除了enum以外所有内置验证器都是这样写 enum:&#123;values:[\"aaa\",\"bbb\"],message:\"没在枚举中。。。 &#123;PATH&#125; - &#123;VALUE&#125;\"&#125;, //枚举时，自定义错误信息比较特殊，是对象形式 validate:&#123; //自定义校验器要这样写，也是对象 validator(value,cb)&#123; setTimeout(function() &#123; cb(false) //模拟异步错误 &#125;) &#125;, message:\"校验错误 &#123;PATH&#125; - &#123;VALUE&#125;\" &#125; &#125;, password:&#123; type:String, required:[true,\"密码必须填写\"], minlength:[6,\"密码至少6位\"] &#125;&#125;))const u = new User(&#123; loginname:\"aaa11\"&#125;)u.validate(function(err)&#123;// const &#123;path,value,message&#125; = err.errors.loginname// console.log(path);// console.log(value);// console.log(message); if(err &amp;&amp; err.errors)&#123; const keys = Object.keys(err.errors) let str = \"\" keys.map((v,i) =&gt; &#123; str += `$&#123;v&#125;:$&#123;err.errors[v]&#125;\\n` &#125;) console.log(str); &#125; //....&#125;) 例子中{PATH}和{VALUE}是属性名和属性值 加入方法 加入实例方法 schema.methods.xxx 加入静态方法 schema.statics.xxx 加入虚拟方法 getter/setter方法 virtual(‘xxx’).get(handle) virtual(‘xxx’).set(handle)举个栗子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const userSchema = new mongoose.Schema(&#123; firstName: String, secondName: String&#125;)//methods和statics的区别在于this是谁userSchema.methods.getAllName = function()&#123; return this.firstName + '.' + this.secondName //这里的this指的是对象本身&#125;userSchema.statics.getAll = function()&#123; //可以加入回调函数 function(cb)&#123; return this.find(&#123;&#125;) //这里的this指的是User类 可以加入回调函数 this.find(&#123;&#125;,cb)&#125;userSchema.virtual(\"allname\").get(function()&#123; return this.firstName + '.' + this.secondName&#125;) //getter methoduserSchema.virtual(\"allname\").set(function(v)&#123; //Yong.Maple const names = v.split(\".\"); this.firstName = names[0]; this.secondName = names[1];&#125;); //setter methodconst User = mongoose.model(\"User\",userSchema)// const u = new User(&#123;// firstName:\"Yong \",// secondName:\"Maple\"// &#125;)//// console.log(u.getAllName());// User.remove(&#123;&#125;).then(()=&gt;&#123;// User.insertMany([// &#123;firstName:\"Yong\",secondName:\"Maple\"&#125;,// &#123;firstName:\"Zhang\",secondName:\"San\"&#125;,// &#123;firstName:\"Li\",secondName:\"Si\"&#125;// ]).then(()=&gt;&#123;// User.getAll().then(result=&gt; console.log(result))// &#125;)// &#125;)const user = new User(&#123; allname:\"Yong.Maple\"&#125;)user.save()console.log(user); 对象的增删改 obj.save / Class.create / Class.insertMany obj.remove / Class.remove obj.update / Class.update 举个栗子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const User = mongoose.model(\"User\",&#123; name:&#123;type:String,maxlength:10&#125;&#125;)User.remove(&#123;&#125;).then(function()&#123; // --------------save // const user = new User(&#123;name:\"JiaYongfeng\"&#125;) // const promise = user.save() // promise // .then(u =&gt; console.log(u)) // .catch(err =&gt; console.log(err)) // // // user.save(function (err,u)&#123; // console.log(err,u); // &#125;) // --------------create 成功的保存，失败的抛出异常 // User.create(&#123;name:\"Jia\"&#125;,&#123;name:\"Yong\"&#125;) // .then(function(u1,u2)&#123; // console.log(u1,u2); // &#125;).catch(err =&gt; console.log(err)) // User.create([&#123;name:\"Jia\"&#125;,&#123;name:\"Yong1111\"&#125;]) // .then(function(arr)&#123; // console.log(arr); // &#125;).catch(err =&gt; console.log(err)) // ------------------insertMany 必须是数组，一条失败，全部失败 // User.insertMany([&#123;name:\"Jia\"&#125;,&#123;name:\"Yong\"&#125;]) // .then(function(arr)&#123; // console.log(arr); // &#125;).catch(err =&gt; console.log(err)) // --------------------remove // User.insertMany([&#123;name:\"Jia22\"&#125;,&#123;name:\"Jia33\"&#125;,&#123;name:\"Jiasasd\"&#125;,&#123;name:\"Yong\"&#125;]) // .then(function(arr)&#123; // User.remove(&#123;name:/^Jia\\d*$/&#125;).then(r =&gt; console.log(r)) // User.remove(&#123;name:\"Jia\"&#125;).then(r =&gt; console.log(r)) // arr[0].remove() // .then(obj =&gt; User.create(&#123;name:obj.name + \" ----- reborn\"&#125;)) // .catch(err =&gt; console.log(err)) // arr[0].remove(function(err,obj)&#123; // console.log(err,obj); // &#125;) // &#125;).catch(err =&gt; console.log(err)) // -----------------------update User.insertMany([&#123;name:\"Jia22\"&#125;,&#123;name:\"Jia33\"&#125;,&#123;name:\"Jiasasd\"&#125;,&#123;name:\"Yong\"&#125;]) .then(function(arr)&#123; User.update(&#123;&#125;,&#123;name:\"YongFeng\"&#125;,&#123;multi:true&#125;,function(err,result)&#123; //默认只修改第一个符合条件的值,需要修改多个要加&#123;multi:true&#125; console.log(err,result); &#125;) // console.log(\"before update ==&gt;\",arr[0]); // arr[0].update(&#123;name:\"123123123123fsdsdfddfsdfdsasdas\"&#125;,&#123;runValidators:true&#125;).then(function(result)&#123; // console.log(result); // &#125;).catch(err =&gt; console.log(err)) &#125;).catch(err =&gt; console.log(err))&#125;) 字段更改参数 $inc 加法运算 $mul 乘法运算 $min / $max 数值和日期的限定 $currentDate 设定当前日期举个栗子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")var Topic = mongoose.model(\"Topic\", new mongoose.Schema(&#123; title: &#123; type: String, required: true &#125;, body: &#123; type: String, required: true &#125;, money: &#123; type: Number, default: 0.5 &#125;, accessNum: &#123; type: Number, default: 0 &#125;, createTime: Date, updateTime: Date&#125;))Topic.remove(&#123;&#125;, function() &#123; const date = new Date var topic = new Topic(&#123; title: \"aa\", body: \"content\", createTime: date, updateTime: date &#125;) topic.save(function(err, result) &#123; Topic.update(&#123;&#125;, &#123; title: \"my js\", $currentDate:&#123; //使用当前时间修改updateTime的值 updateTime:true &#125;, $min: &#123; //最小值，和平时理解的不一样，必须小于15，不超过15变成15 accessNum: 15 //15 &#125;, // $max: &#123; //最大值，和平时理解的不一样，必须大于15，不满15变成15 // accessNum: 15 //15 // &#125; //每个参数只能在一个算法当中 // $mul: &#123; //乘 // money: 3 //1.5 // &#125;, // $inc: &#123; //加 // accessNum: 2 //2 // &#125; &#125;, function(err) &#123; &#125;) &#125;)&#125;) 数组类型字段的更改参数 $pop 删除一条数据 $addToSet 添加去重数据 $pull / $pullAll 清除 $push 加入数据举个栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const Topic = mongoose.model(\"Topic\", &#123; arr: []&#125;)Topic.remove(&#123;&#125;, function() &#123; Topic.create(&#123; arr: [11, 22,11, 33, 44, 55, 66] &#125;).then(function() &#123; // $pop删除一个 // Topic.update(&#123;&#125;, &#123; // $pop: &#123; // arr: 1 //[11, 22, 33, 44, 55] 正数从后往前，负数从前往后 // //arr: -1 //[ 22, 33, 44, 55, 66] // &#125; // &#125;).exec() // $addToSet添加不重复 // Topic.update(&#123;&#125;, &#123; // $addToSet: &#123; // // arr: 66 //如果重复，无法添加 // // arr: [77,88] //[11, 22, 33, 44, 55, 66, [77,88]]并不是预期的效果 // arr: &#123; // $each: [77, 88] //[ 11, 22, 33, 44, 55, 66, 77, 88 ] // &#125; // &#125; // &#125;).exec() // $pull删除一种数据 // Topic.update(&#123;&#125;,&#123; // $pull:&#123; // arr:11 //[ 22, 33, 44, 55, 66 ] // // arr:[11,22] //无效的 // &#125; // &#125;).exec() // $pullAll删除多种数据 // Topic.update(&#123;&#125;,&#123; // $pullAll:&#123; // arr:[11,22] //[ 33, 44, 55, 66 ] // &#125; // &#125;).exec() // $push添加数据，可以重复 Topic.update(&#123;&#125;,&#123; $push:&#123; // arr:66 //[ 11, 22, 11, 33, 44, 55, 66, 66 ] arr:&#123; $each: [77, 88], $position:0, //从指定位置开始添加[ 77, 88, 11, 22, 11, 33, 44, 55, 66 ] $slice:-3 //截取数组，正数从前截取，负数从后截取 &#125; &#125; &#125;).exec() &#125;)&#125;) 对象的基础查询 find(conditions , [projection] , [options] , [callback]) findById findByIdAndRemove / findByIdAndUpdate findOne findOneAndRemove / findOneAndUpdate举个栗子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const Topic = mongoose.model(\"Topic\", &#123; name: &#123; type: String, maxlength: 10 &#125;&#125;)const arr = []for (let i = 0; i &lt; 50; i++) &#123; arr.push(&#123; name: \"Jimmy\" + i &#125;)&#125;Topic.remove(&#123;&#125;, function() &#123; Topic.create(arr).then(function(objs) &#123; let id = objs[0].id // Topic.findById(id, function(err, t) &#123; // console.log(t); // &#125;) // Topic.findByIdAndRemove(id, function(err, t) &#123; // console.log(t); // &#125;) // Topic.findByIdAndUpdate(id, &#123; // name: \"hahahaha111111111\" // &#125;, &#123; // runValidators: true // &#125;, function(err, t) &#123; // console.log(err, t); // &#125;) // 上面这个和这个一样的效果 // Topic.findByIdAndUpdate(id, &#123; // name: \"hahahaha111111111\" // &#125;, &#123; // runValidators: true // &#125;).then(function(t) &#123; // console.log(t); // &#125;).catch(err =&gt; console.log(err)) // 效果还是一样的，错误交由外部处理 // return Topic.findByIdAndUpdate(id, &#123; // name: \"hahahaha111111111\" // &#125;, &#123; // runValidators: true // &#125;).then(function(t) &#123; // console.log(t); // &#125;) // Topic.findOne(&#123;name:/^Jimmy1\\d$/&#125;,function(err,t)&#123; //返回满足条件的第一个 // console.log(t); // &#125;) // Topic.find(&#123;&#125;,function(err,ts)&#123; // console.log(ts); // &#125;) // Topic.find(&#123;name:/^Jimmy1\\d$/&#125;,function(err,ts)&#123; // console.log(ts); // &#125;) // Topic.find(&#123;name:/^Jimmy1\\d$/&#125;,\"_id name\",function(err,ts)&#123; //第二个参数决定返回结果带有的属性，用空格分割，如果在属性前加-，则表示不返回这个属性 // console.log(ts); // &#125;) Topic.find(&#123;name:/^Jimmy1\\d$/&#125;,null,&#123;skip:5,limit:3&#125;,function(err,ts)&#123; //第三个参数是对结果的筛选，skip指跳过几个，limit指最多返回几个，结合这两个可以实现翻页功能 console.log(ts); &#125;) &#125;).catch(err =&gt; console.log(err))&#125;) 比较式查询 大小判断 $eq 等于 $gt 大于 $gte 大于等于 $lt 小于 $lte 小于等于 $ne 不是 $in 包含 $nin 不包含举个栗子 1234567891011121314151617181920212223242526272829303132333435363738var mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const Topic = mongoose.model(\"Topic\", &#123; name: &#123; type: String, maxlength: 10 &#125;, num: Number&#125;)const arr = []for (let i = 0; i &lt; 50; i++) &#123; arr.push(&#123; name: \"Jimmy\" + i, num: i &#125;)&#125;Topic.remove(&#123;&#125;, function() &#123; Topic.create(arr).then(function(objs) &#123; Topic.find(&#123; num: &#123; // $lt: 20, //小于20 // $lte:20, //小于等于20 // $gt:10, //大于10 // $gte:10, //大于等于10 // $in: [11, 15], //值等于11或15 // $nin: [11, 15], //值不等于11或15 // $ne: 2, //不等于2的，只能一个值 $eq: 2, //等于2的 &#125; &#125;, function(err, ts) &#123; console.log(ts); &#125;) &#125;)&#125;) 逻辑式查询 $or 或 $nor ($or相反) $and 和 $not 否举个栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const Topic = mongoose.model(\"Topic\", &#123; name: &#123; type: String, maxlength: 10 &#125;, num: Number&#125;)const arr = []for (let i = 0; i &lt; 50; i++) &#123; arr.push(&#123; name: \"Jimmy\" + i, num: i &#125;)&#125;Topic.remove(&#123;&#125;, function() &#123; Topic.create(arr).then(function(objs) &#123; Topic.find(&#123; // $or: [&#123; //满足一个条件就会返回 // name: \"Jimmy1\" // &#125;, &#123; // num: 4 // &#125;,&#123; // num: 6 // &#125;] // $nor: [&#123; //不满足所有条件就返回 // name: \"Jimmy1\" // &#125;, &#123; // num: 4 // &#125;, &#123; // num: 6 // &#125;] // $and: [&#123; //满足所有条件才返回 // name: /^Jimmy1\\d$/ // &#125;, &#123; // num: &#123; // $lte:15 // &#125; // &#125;] // $and: [&#123; //可以混合使用 // $or: [&#123; // name: \"Jimmy1\" // &#125;, &#123; // num: 4 // &#125;, &#123; // num: 6 // &#125;] // &#125;, &#123; // num: 4 // &#125;] num: &#123; $not: &#123; //不满足条件的返回 $gte: 10 &#125; &#125; &#125;, function(err, ts) &#123; console.log(ts); &#125;) &#125;)&#125;) 数组专用查询 $all 是否包含查询条件 $elemMatch 数组元素查询条件 $size 数组大小查询条件 $where 其他举个栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899var mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")//$all&amp;$elemMatch// const Topic = mongoose.model(\"Topic\", &#123;// arr: []// &#125;)//$all// Topic.remove(&#123;&#125;, function() &#123;// Topic.create([&#123;// arr: [11, 22, 33]// &#125;,// &#123;// arr: [33, 44, 55]// &#125;,// &#123;// arr: [55, 66, 77, 88]// &#125;// ]).then(function() &#123;// Topic.find(&#123;// arr: &#123;// $all: [33, 44] //都存在的返回// &#125;// &#125;).then((result) =&gt; &#123;// console.log(result);// &#125;)// &#125;)// &#125;)//$elemMatch// function generatorArr(size) &#123;// let arr = []// for (let i = 0; i &lt; size; i++) &#123;// arr.push(&#123;// name: \"Jimmy\" + i,// num: i// &#125;)// &#125;// return arr// &#125;//// Topic.remove(&#123;&#125;, function() &#123;// Topic.create([&#123;// arr: generatorArr(5)// &#125;,// &#123;// arr: generatorArr(10)// &#125;,// &#123;// arr: generatorArr(15)// &#125;// ]).then(function() &#123;// Topic.find(&#123;// arr: &#123;// // $elemMatch: &#123; //匹配数组内部元素的数据// // name: \"Jimmy9\"// // &#125;// $size: 5 //匹配数组length// &#125;// &#125;).then((result) =&gt; &#123;// console.log(result);// &#125;)// &#125;)// &#125;)//$whereconst Topic = mongoose.model(\"Topic\", &#123; obj: &#123;&#125;&#125;)Topic.remove(&#123;&#125;, function() &#123; Topic.create([&#123; obj: &#123; name: \"java\", num: 1 &#125; &#125;, &#123; obj: &#123; name: \"javascript\", num: 2 &#125; &#125;, &#123; obj: &#123; name: \"nodejs\", num: 3 &#125; &#125;]).then(function() &#123; Topic.find(&#123; // $where: \"this.obj.name === 'java'\" //直接写js $where: function() &#123; return /^java\\w*$/.test(this.obj.name) &amp;&amp; this.obj.num === 2 &#125; &#125;, null, &#123; //同样可以混合使用 limit: 2, skip: 0 &#125;).then(function(result) &#123; console.log(result); &#125;) &#125;)&#125;) Query查询风格另一种风格的写法，作为了解，下面例子将会改写上面的例子举个栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Topic.create([&#123; arr: [11, 22, 33] &#125;, &#123; arr: [33, 44, 55] &#125;, &#123; arr: [55, 66, 77, 88] &#125;]).then(function() &#123; let query = Topic.find() query.where(\"arr\") .all([33,44]) .limit(3) .skip(10) .select(\"name age\") .exec(function (err,result)&#123; console.log(result) &#125;)&#125;)//elemMatch的query写法Topic.create([&#123; arr: generatorArr(5) &#125;, &#123; arr: generatorArr(10) &#125;, &#123; arr: generatorArr(15) &#125;]).then(function() &#123; Topic.find() .where(\"arr\") .elemMatch(&#123;name:\"Jimmy9\"&#125;) .exec(function (err,result)&#123; console.log(result) &#125;) //另一种写法 Topic.find() .where(\"arr\") .elemMatch(function (elem)&#123; elem.where(\"name\").eq(\"Jimmy9\").where(\"num\").gte() .... &#125;) .exec(function (err,result)&#123; console.log(result) &#125;)&#125;) 具体可以查看文档http://mongoosejs.com/docs/queries.html 中间件会触发中间件的： validate doc.save Class.create / Class.insertMany doc.update doc.remove find findOne findAndRemove / findOneAndUpdate举个栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var mongoose = require(\"mongoose\")mongoose.connect(\"mongodb://localhost/test\")const userSchema = new mongoose.Schema(&#123; name: &#123; type: String, maxlength: 5 &#125;&#125;)userSchema.pre(\"validate\", function(next) &#123; console.log(\"pre validate\"); console.log(this.errors); next()&#125;)userSchema.post(\"validate\", function() &#123; // console.log(this.errors?this.errors.name.message:this.errors); console.log(\"post validate\");&#125;)// userSchema.pre(\"save\", function(next) &#123;// console.log(\"pre save one\");// next()// &#125;)userSchema.pre(\"save\",true, function(next,done) &#123; //默认不加true，加true表示并行,在执行完所有的pre之后在执行后面的，没什么卵用的功能，完全能用next来控制 console.log(\"pre save one\"); next() setTimeout(done,2000)&#125;)userSchema.pre(\"save\", function(next) &#123; console.log(\"pre save two\"); setTimeout(next,2000)&#125;)userSchema.post(\"save\", function() &#123; console.log(\"post save\");&#125;)userSchema.pre(\"update\", function(next) &#123; console.log(\"pre update\"); next()&#125;)userSchema.post(\"update\", function() &#123; console.log(\"post update\");&#125;)userSchema.pre(\"remove\", function(next) &#123; console.log(\"pre remove\"); next()&#125;)userSchema.post(\"remove\", function() &#123; console.log(\"post remove\");&#125;)const User = mongoose.model(\"User\", userSchema)User.remove(&#123;&#125;, function() &#123; var user = new User(&#123; name: \"Jia\" &#125;) user.save(function(err, u) &#123; u.update(&#123; name: \"Jimmy\" &#125;).then(function(result)&#123; u.remove() &#125;) &#125;)&#125;) END","categories":[{"name":"教程","slug":"教程","permalink":"http://YongMaple.github.io/categories/教程/"},{"name":"Mongoose","slug":"教程/Mongoose","permalink":"http://YongMaple.github.io/categories/教程/Mongoose/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://YongMaple.github.io/tags/mongodb/"},{"name":"mongoose","slug":"mongoose","permalink":"http://YongMaple.github.io/tags/mongoose/"}]},{"title":"IOS设置document.title无效的解决办法","slug":"IOS设置document-title无效的解决办法","date":"2017-02-04T08:54:52.000Z","updated":"2017-02-04T08:56:15.000Z","comments":true,"path":"2017/02/04/IOS设置document-title无效的解决办法/","link":"","permalink":"http://YongMaple.github.io/2017/02/04/IOS设置document-title无效的解决办法/","excerpt":"","text":"问题原因：因为浏览器首次加载页面初始化title后，就再也不监听 document.title的change事件。 解决方案：修改title之后，给页面加上一个内容为空的iframe，随后立即删除这个iframe，这时候会刷新title。但是如果简单的这样设置，一般是会有闪动的，所以可以设置 12345678910setTitle: function(title) &#123; let $body = $('body') document.title = title let $iframe = $('&lt;iframe src=\"/favicon.ico\"&gt;&lt;/iframe&gt;') $iframe.on('load', function() &#123; setTimeout(function() &#123; $iframe.off('load').remove() &#125;, 0) &#125;).appendTo($body) &#125; 参考地址：http://www.cnblogs.com/lihanying/p/6227192.html","categories":[{"name":"编程思考","slug":"编程思考","permalink":"http://YongMaple.github.io/categories/编程思考/"}],"tags":[{"name":"title","slug":"title","permalink":"http://YongMaple.github.io/tags/title/"},{"name":"ios","slug":"ios","permalink":"http://YongMaple.github.io/tags/ios/"},{"name":"手机端","slug":"手机端","permalink":"http://YongMaple.github.io/tags/手机端/"}]},{"title":"iTerm2配色修改","slug":"iTerm2配色修改","date":"2017-02-04T02:25:12.000Z","updated":"2017-02-04T02:57:49.000Z","comments":true,"path":"2017/02/04/iTerm2配色修改/","link":"","permalink":"http://YongMaple.github.io/2017/02/04/iTerm2配色修改/","excerpt":"","text":"首先sudo vim ~/.bash_profile，输入密码后按e进入编辑，看别人的帖子是不需要sudo的。。。但是我需要 然后i进入编辑模式，加入下面这段，然后esc输入:wq保存 1234567891011#enables colorin the terminal bash shell exportexport CLICOLOR=1#sets up thecolor scheme for list exportexport LSCOLORS=gxfxcxdxbxegedabagacad#sets up theprompt color (currently a green similar to linux terminal)export PS1='\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;36m\\]\\w\\[\\033[00m\\]\\$ '#enables colorfor iTermexport TERM=xterm-color 然后修改preference-&gt;profiles-&gt;Terminal-&gt;xterm-new 去挑选喜欢的配色方案，我在这里找的http://iterm2colorschemes.com/ 下载到你喜欢的配色后，导入导入后选择你的配色，然后注销mac，再打开就发现配色变了，之后再换配色只要直接改就行了","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://YongMaple.github.io/categories/工具使用/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://YongMaple.github.io/tags/开发工具/"},{"name":"iTerm2","slug":"iTerm2","permalink":"http://YongMaple.github.io/tags/iTerm2/"}]},{"title":"Retina视网膜屏幕适配","slug":"Retina视网膜屏幕适配","date":"2017-01-19T07:10:57.000Z","updated":"2017-01-19T07:11:49.000Z","comments":true,"path":"2017/01/19/Retina视网膜屏幕适配/","link":"","permalink":"http://YongMaple.github.io/2017/01/19/Retina视网膜屏幕适配/","excerpt":"","text":"1234567891011121314151617181920212223242526272829&lt;!DOCTYPE&gt;&lt;html&gt;&lt;header&gt; &lt;style&gt; div &#123; border: 1px solid #bbb; &#125; .hairlines div &#123; border-width: .5px; &#125; &lt;/style&gt;&lt;/header&gt;&lt;body&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; if (window.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= 2) &#123; var testElem = document.createElement('div'); testElem.style.border = '.5px solid transparent'; document.body.appendChild(testElem); if (testElem.offsetHeight == 1)&#123; document.querySelector('html').classList.add('hairlines'); &#125; document.body.removeChild(testElem); &#125;&lt;/script&gt;&lt;/html&gt; window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：window.devicePixelRatio = 物理像素 / dips offsetHeight = clientHeight + 滚动条 + 边框 如果是retina屏，会先创建个div来测试浏览器是否能探测到0.5px，如果可以会才会使用0.5px的样式 原文地址：http://dieulot.net/css-retina-hairline","categories":[{"name":"编程思考","slug":"编程思考","permalink":"http://YongMaple.github.io/categories/编程思考/"}],"tags":[{"name":"手机端","slug":"手机端","permalink":"http://YongMaple.github.io/tags/手机端/"},{"name":"适配","slug":"适配","permalink":"http://YongMaple.github.io/tags/适配/"},{"name":"Retina","slug":"Retina","permalink":"http://YongMaple.github.io/tags/Retina/"}]},{"title":"ES6-遍历对象属性","slug":"ES6-遍历对象属性","date":"2017-01-19T07:07:58.000Z","updated":"2017-01-19T07:09:55.000Z","comments":true,"path":"2017/01/19/ES6-遍历对象属性/","link":"","permalink":"http://YongMaple.github.io/2017/01/19/ES6-遍历对象属性/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class A &#123; constructor() &#123; this.name = 'leo'; &#125; getName() &#123; &#125;&#125;class B extends A&#123; constructor()&#123; super(); this.age = 22; &#125; getAge()&#123; &#125; [Symbol('fullname')]()&#123; &#125;&#125;B.prototype.getClass = function () &#123;&#125;;var b = new B;// Object.keys 能够得到自身的可枚举的属性,但得不到原型链上的属性.// 得不到 Symbols 属性console.log(Object.keys(B.prototype));// Object.getOwnPropertyNames(b) 能够得到自身属性,// 包括不可枚举的属性,但得不到原型链上的属性.// 得不到 Symbols 属性console.log(Object.getOwnPropertyNames(B.prototype));// 可以得到自身的 Symbols 属性,包括不可枚举的属性.console.log(Object.getOwnPropertySymbols(B.prototype));// 可以得到自身和继承的原型链上的属性,但必须是可枚举属性.for(let key in b)&#123; console.log(key);&#125;// 判断是否可枚举，enumerable为true可枚举console.log(Object.getOwnPropertyDescriptor(B.prototype,'getAge'));","categories":[{"name":"ES6笔记","slug":"ES6笔记","permalink":"http://YongMaple.github.io/categories/ES6笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://YongMaple.github.io/tags/ES6/"}]},{"title":"ES6-Object.assign","slug":"ES6-Object-assign","date":"2017-01-19T07:07:47.000Z","updated":"2017-01-19T07:09:28.000Z","comments":true,"path":"2017/01/19/ES6-Object-assign/","link":"","permalink":"http://YongMaple.github.io/2017/01/19/ES6-Object-assign/","excerpt":"","text":"Object.assign将可以枚举的属性赋值给对象12345678910111213141516171819var obj = &#123;&#125;;var skey = Symbol('testname');var obj2 = Object.assign(obj, &#123;name: 'leo'&#125;, &#123;age: 30&#125;,&#123;[skey]:'ok good'&#125;);console.log(obj === obj2, obj);console.log(obj[skey]);const DEFAULT_OPTIONS = &#123; name: 'leo'&#125;;function test(opts) &#123; let options = Object.assign(&#123;&#125;, DEFAULT_OPTIONS, opts); console.log(options);&#125;test();test(&#123;name:'zengliang'&#125;);","categories":[{"name":"ES6笔记","slug":"ES6笔记","permalink":"http://YongMaple.github.io/categories/ES6笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://YongMaple.github.io/tags/ES6/"}]},{"title":"ES6-Object.is","slug":"ES6-Object-is","date":"2017-01-19T07:07:35.000Z","updated":"2017-01-19T07:09:11.000Z","comments":true,"path":"2017/01/19/ES6-Object-is/","link":"","permalink":"http://YongMaple.github.io/2017/01/19/ES6-Object-is/","excerpt":"","text":"Object.is相当于全等又有些区别123console.log(Object.is(&#123;&#125;,&#123;&#125;) , &#123;&#125; === &#123;&#125; ); //fasle falseconsole.log(Object.is(NaN,NaN) , NaN === NaN); //true falseconsole.log(Object.is(+0,-0) , +0 === -0); //false true","categories":[{"name":"ES6笔记","slug":"ES6笔记","permalink":"http://YongMaple.github.io/categories/ES6笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://YongMaple.github.io/tags/ES6/"}]},{"title":"ES6-对象属性的新写法","slug":"ES6-对象属性的新写法","date":"2017-01-19T07:07:22.000Z","updated":"2017-01-19T07:08:46.000Z","comments":true,"path":"2017/01/19/ES6-对象属性的新写法/","link":"","permalink":"http://YongMaple.github.io/2017/01/19/ES6-对象属性的新写法/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class A &#123; constructor() &#123; this.name = 'leo'; &#125; getName() &#123; &#125;&#125;class B extends A&#123; constructor()&#123; super(); this.age = 22; &#125; getAge()&#123; &#125; [Symbol('fullname')]()&#123; &#125;&#125;B.prototype.getClass = function () &#123;&#125;;var b = new B;// Object.keys 能够得到自身的可枚举的属性,但得不到原型链上的属性.// 得不到 Symbols 属性console.log(Object.keys(B.prototype));// Object.getOwnPropertyNames(b) 能够得到自身属性,// 包括不可枚举的属性,但得不到原型链上的属性.// 得不到 Symbols 属性console.log(Object.getOwnPropertyNames(B.prototype));// 可以得到自身的 Symbols 属性,包括不可枚举的属性.console.log(Object.getOwnPropertySymbols(B.prototype));// 可以得到自身和继承的原型链上的属性,但必须是可枚举属性.for(let key in b)&#123; console.log(key);&#125;// 判断是否可枚举，enumerable为true可枚举console.log(Object.getOwnPropertyDescriptor(B.prototype,'getAge'));","categories":[{"name":"ES6笔记","slug":"ES6笔记","permalink":"http://YongMaple.github.io/categories/ES6笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://YongMaple.github.io/tags/ES6/"}]},{"title":"JS-forEach和map","slug":"JS-forEach和map","date":"2017-01-18T02:38:49.000Z","updated":"2017-02-04T07:40:50.000Z","comments":true,"path":"2017/01/18/JS-forEach和map/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/JS-forEach和map/","excerpt":"","text":"第1个是遍历的数组内容；第2个是对应的数组索引;第3个是数组本身123[].forEach(function(value, index, array) &#123; // ...&#125;); 举个栗子1234[1,2,3,4,5].map(function(v, i)&#123;return v &gt; 3;&#125;);//[false, false, false, true, true][1,2,3,4,5].forEach(function(v, i)&#123;return v &gt; 3;&#125;);//undefined map()方法：若这个回调函数有返回值，map()方法会产生一个新数组，这个新数组由原数组元素对应的回调函数的返回值构成。若没有返回值，则新数组的所有元素为undefined。forEach方法：仅仅为每个数组元素执行回调函数。 再举一个1234567var result = [1, 2, 3, 4, 5].map(function(v, i) &#123; return v+1&#125;);console.log(result); //[2, 3, 4, 5, 6][1, 2, 3, 4, 5].forEach(function(v, i) &#123; console.log(v,i) //1 0&#125;);","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://YongMaple.github.io/categories/JS基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://YongMaple.github.io/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://YongMaple.github.io/tags/JS/"},{"name":"基础","slug":"基础","permalink":"http://YongMaple.github.io/tags/基础/"},{"name":"forEach","slug":"forEach","permalink":"http://YongMaple.github.io/tags/forEach/"},{"name":"map","slug":"map","permalink":"http://YongMaple.github.io/tags/map/"}]},{"title":"JS-sort","slug":"JS-sort","date":"2017-01-18T02:37:54.000Z","updated":"2017-02-04T07:40:16.000Z","comments":true,"path":"2017/01/18/JS-sort/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/JS-sort/","excerpt":"","text":"12345var arr=new Array(1,8,7,6);arr.sort(function(a,b)&#123; return b-a&#125;);console.log(arrSimple2.join()); 解释：a,b表示数组中的任意两个元素，若return &gt; 0 b前a后；reutrn &lt; 0 a前b后；a=b时存在浏览器兼容简化一下：a-b输出从小到大排序，b-a输出从大到小排序。1234567891011121314151617var objectList = new Array();function Persion(name, age) &#123; this.name = name; this.age = age;&#125;objectList.push(new Persion('jack', 20));objectList.push(new Persion('tony', 25));objectList.push(new Persion('stone', 26));objectList.push(new Persion('mandy', 23));//按年龄从小到大排序objectList.sort(function(a, b) &#123; return a.age - b.age&#125;);for (var i = 0; i &lt; objectList.length; i++) &#123; console.log('age:' + objectList[i].age + ' name:' + objectList[i].name);&#125; 也可以对对象的属性进行排序","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://YongMaple.github.io/categories/JS基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://YongMaple.github.io/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://YongMaple.github.io/tags/JS/"},{"name":"基础","slug":"基础","permalink":"http://YongMaple.github.io/tags/基础/"},{"name":"sort","slug":"sort","permalink":"http://YongMaple.github.io/tags/sort/"}]},{"title":"JS-match和exec","slug":"JS-match和exec","date":"2017-01-18T02:34:52.000Z","updated":"2017-01-18T02:35:35.000Z","comments":true,"path":"2017/01/18/JS-match和exec/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/JS-match和exec/","excerpt":"","text":"举个栗子12345678var order = 'is2'var arr = order.match(/\\d+/)console.log(arr)//[\"2\", index: 2, input: \"is2\"]var arr2 = /\\d+/.exec(order);console.log(arr2)//[\"2\", index: 2, input: \"is2\"] 值得注意的是match和exec返回的结果都是数组","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://YongMaple.github.io/categories/JS基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://YongMaple.github.io/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://YongMaple.github.io/tags/JS/"},{"name":"基础","slug":"基础","permalink":"http://YongMaple.github.io/tags/基础/"},{"name":"match","slug":"match","permalink":"http://YongMaple.github.io/tags/match/"},{"name":"exec","slug":"exec","permalink":"http://YongMaple.github.io/tags/exec/"},{"name":"正则","slug":"正则","permalink":"http://YongMaple.github.io/tags/正则/"}]},{"title":"JS-includes和indexOf","slug":"JS-includes和indexOf","date":"2017-01-18T02:33:03.000Z","updated":"2017-01-18T02:34:18.000Z","comments":true,"path":"2017/01/18/JS-includes和indexOf/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/JS-includes和indexOf/","excerpt":"","text":"举个栗子123456var str = 'hahaha123'console.log(str.includes('1')); //trueconsole.log(str.indexOf('1')); //6var arr = [1,2,3,4,5]console.log(arr.includes(1)); //trueconsole.log(arr.indexOf(1)); //0","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://YongMaple.github.io/categories/JS基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://YongMaple.github.io/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://YongMaple.github.io/tags/JS/"},{"name":"基础","slug":"基础","permalink":"http://YongMaple.github.io/tags/基础/"},{"name":"includes","slug":"includes","permalink":"http://YongMaple.github.io/tags/includes/"},{"name":"indexOf","slug":"indexOf","permalink":"http://YongMaple.github.io/tags/indexOf/"}]},{"title":"JS-join拼接","slug":"JS-join拼接","date":"2017-01-18T02:30:45.000Z","updated":"2017-01-18T02:32:06.000Z","comments":true,"path":"2017/01/18/JS-join拼接/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/JS-join拼接/","excerpt":"","text":"123456var arr = new Array(3)arr[0] = \"George\"arr[1] = \"John\"arr[2] = \"Thomas\"console.log(arr.join(' ')) //George John Thomas","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://YongMaple.github.io/categories/JS基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://YongMaple.github.io/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://YongMaple.github.io/tags/JS/"},{"name":"基础","slug":"基础","permalink":"http://YongMaple.github.io/tags/基础/"},{"name":"数组","slug":"数组","permalink":"http://YongMaple.github.io/tags/数组/"},{"name":"拼接","slug":"拼接","permalink":"http://YongMaple.github.io/tags/拼接/"}]},{"title":"JS-arguments","slug":"JS-arguments","date":"2017-01-18T02:29:30.000Z","updated":"2017-01-18T02:31:18.000Z","comments":true,"path":"2017/01/18/JS-arguments/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/JS-arguments/","excerpt":"","text":"123456function test(a,b) &#123; console.log(arguments); //[\"123\"] console.log(arguments.length); //1 console.log(test.length); //2&#125;test('123') 通过arguments可以获取传入的参数，function.length可以获取本该传入的参数","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://YongMaple.github.io/categories/JS基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://YongMaple.github.io/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://YongMaple.github.io/tags/JS/"},{"name":"基础","slug":"基础","permalink":"http://YongMaple.github.io/tags/基础/"},{"name":"参数","slug":"参数","permalink":"http://YongMaple.github.io/tags/参数/"}]},{"title":"JS-数组比较","slug":"JS-数组比较","date":"2017-01-18T02:27:39.000Z","updated":"2017-01-18T02:31:39.000Z","comments":true,"path":"2017/01/18/JS-数组比较/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/JS-数组比较/","excerpt":"","text":"12345var x = [1,2];var y = [1,2];console.log(x == y); //falseconsole.log(x === y ); //false javascript不能直接用==或者===来判断两个数组是否相等，无论是相等还是全等都不行。要判断数组是否相等，要先将数组转换为字符串，再作比较123var x = [1,2];var y = [1,2];console.log(x.toString() == y.toString())","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://YongMaple.github.io/categories/JS基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://YongMaple.github.io/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://YongMaple.github.io/tags/JS/"},{"name":"基础","slug":"基础","permalink":"http://YongMaple.github.io/tags/基础/"},{"name":"数组","slug":"数组","permalink":"http://YongMaple.github.io/tags/数组/"},{"name":"比较","slug":"比较","permalink":"http://YongMaple.github.io/tags/比较/"}]},{"title":"JS-String转数字类型","slug":"JS-String转数字类型","date":"2017-01-18T02:24:43.000Z","updated":"2017-01-18T02:31:48.000Z","comments":true,"path":"2017/01/18/JS-String转数字类型/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/JS-String转数字类型/","excerpt":"","text":"需要将string转成数字时，如果需要保留小数，只要用+就行了123456var str = '123'console.log(parseInt(str))//转整数时没问题var str1 = '123.45'console.log(+str1)//只要用+就行了","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://YongMaple.github.io/categories/JS基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://YongMaple.github.io/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"http://YongMaple.github.io/tags/JS/"},{"name":"基础","slug":"基础","permalink":"http://YongMaple.github.io/tags/基础/"},{"name":"转换","slug":"转换","permalink":"http://YongMaple.github.io/tags/转换/"}]},{"title":"ES6-set","slug":"ES6-set","date":"2017-01-18T02:22:29.000Z","updated":"2017-01-18T02:22:52.000Z","comments":true,"path":"2017/01/18/ES6-set/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/ES6-set/","excerpt":"","text":"是什么？set是类数组 可以用来做什么？可以用来给数组去重123let arr = ['jiayongfeng','jimmy','jimmy']let newArr = Array.from(new Set(arr))console.log(newArr) 怎么用？12345678910let user = &#123;name:'jiayongfeng',age:'28'&#125;let st = new Set() st.add(user) //添加st.delete(user) //删除st.has(user) //判断有无st.clear() //清空console.log(st.size) //查看数量for(let o of st)&#123; //遍历 console.log(o)&#125;","categories":[{"name":"ES6笔记","slug":"ES6笔记","permalink":"http://YongMaple.github.io/categories/ES6笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://YongMaple.github.io/tags/ES6/"}]},{"title":"ES6-map","slug":"ES6-map","date":"2017-01-18T02:21:15.000Z","updated":"2017-02-24T03:12:01.000Z","comments":true,"path":"2017/01/18/ES6-map/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/ES6-map/","excerpt":"","text":"是什么？map是键值对的类数组 可以用来做什么？对象中的key必须是string，map中key可以是任意值123456789let user = &#123; name : 'jiayongfeng', age : 28, 'english name':'jimmy'&#125;let map = new Map([ [user,'shuai'], //key可以是对象 ['qq','740534248']]) 怎么用？12345678910111213141516171819202122232425262728293031let map = new Map()map.set('name','jiayongfeng') //赋值map.set('age',28)console.log(map.get('age')) //取值console.log(map.size) //查看大小map.delete('age') //删除map.has('name') //判断有无map.clear() //清空//值得注意NaN在map和set是全等的console.log(NaN === NaN) //falsemap.set(NaN,'1111');map.set(NaN,'2222');console.log(map.get(NaN)); //2222for(let o of map)&#123; //遍历 console.log(o)&#125;let keys = map.keys() //获取所有的keylet values = map.values() //获取所有的valuelet entries = map.entries() //获取所有的键值对for(let o of entries)&#123; console.log(o) //等同于上面的遍历&#125;var _this = &#123; des : 'shuai'&#125;;map.forEach(function (k, v) &#123; //遍历，同时可以传入this console.log(this.des,k, v);&#125;,_this);","categories":[{"name":"ES6笔记","slug":"ES6笔记","permalink":"http://YongMaple.github.io/categories/ES6笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://YongMaple.github.io/tags/ES6/"}]},{"title":"ES6-Array","slug":"ES6-Array","date":"2017-01-18T02:20:04.000Z","updated":"2017-01-18T02:20:46.000Z","comments":true,"path":"2017/01/18/ES6-Array/","link":"","permalink":"http://YongMaple.github.io/2017/01/18/ES6-Array/","excerpt":"","text":"Array.from类似数组的数据结构转换为数组可以把带有length属性的对象和实现了iterator接口的对象转换为数组123456789101112var arr = Array.from(&#123;'0':'qq 740534248','1':'jimmy','length':2&#125;,function(item,index)&#123; return item + '---' + index&#125;);//必须是这种样子的对象，其他的不行console.log(arr);var set = new Set(['me','book','leo']);console.log(Array.from(set)); querySelectorAll查询出的类数组也能转换12345678910111213&lt;ul&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt; &lt;li&gt;item5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var list = document.querySelectorAll('li'); console.log(list) //NodeList[5] console.log(Array.from(list)); //ArrayList[5]&lt;/script&gt; Array.of用来构建数组，防止Array(7)这种情况发生12345Array.of(7); // [7]Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] find找到符合函数的第一个值1234567var arr = [ 22,33,44,55 ];var value = arr.find(function(value,index,arr)&#123; //值，索引，原数组 return value &gt; 33;&#125;);console.log(value); //44 findIndex找到符合函数的第一个值的索引1234567var arr = [ 22,33,44,55 ];var value = arr.findIndex(function(value,index,arr)&#123; //值，索引，原数组 return value &gt; 33;&#125;);console.log(value); //2 IndexOf比较123456var arr2 = [22,NaN];console.log(arr2.indexOf(NaN)) //-1console.log(arr2.findIndex(function(v)&#123; return Object.is(NaN,v);&#125;)); //1 copyWithincopyWithin(position,start,end);要被替换的开始位置，用于替换的起始位置，用于替换的结束位置（不包含）也可以用负数，代表从后往前数第几个，如-3代表正数第4个12345ar arr = [1,2,3,4,5,6,7];//arr.copyWithin(1,5,7); //[ 1, 6, 7, 4, 5, 6, 7 ]arr.copyWithin(2,-3,6); //[ 1, 2, 5, 6, 5, 6, 7 ]console.log(arr); fill填充数组fill(value,start,end)用来填充的值，被填充的起始位置，被填充的结束位置12345var arr = [1,2,3,4,5,6,7];//arr.fill(10)console.log(arr) //[10,10,10,10,10,10,10]arr.fill(10,2,5)console.log(arr) //[1,2,10,10,10,6,7]","categories":[{"name":"ES6笔记","slug":"ES6笔记","permalink":"http://YongMaple.github.io/categories/ES6笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://YongMaple.github.io/tags/ES6/"}]},{"title":"JavaScript 源代码阅读工具","slug":"JavaScript-源代码阅读工具","date":"2017-01-17T08:41:07.000Z","updated":"2017-01-17T09:00:54.000Z","comments":true,"path":"2017/01/17/JavaScript-源代码阅读工具/","link":"","permalink":"http://YongMaple.github.io/2017/01/17/JavaScript-源代码阅读工具/","excerpt":"","text":"lambda-viewhttps://github.com/Jianru-Lin/lambda-view 命令行输入1lv /path/somewhere/xyz.js 1lv http://vuejs.org/js/vue.js","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://YongMaple.github.io/categories/工具使用/"}],"tags":[{"name":"源代码查看","slug":"源代码查看","permalink":"http://YongMaple.github.io/tags/源代码查看/"}]},{"title":"Atom使用eslint需要安装的包","slug":"Atom使用eslint需要安装的包","date":"2017-01-17T08:39:41.000Z","updated":"2017-01-17T09:00:59.000Z","comments":true,"path":"2017/01/17/Atom使用eslint需要安装的包/","link":"","permalink":"http://YongMaple.github.io/2017/01/17/Atom使用eslint需要安装的包/","excerpt":"","text":"1234567\"dependencies\": &#123; \"eslint\": \"^3.13.1\", \"eslint-config-airbnb\": \"^14.0.0\", \"eslint-plugin-import\": \"^2.2.0\", \"eslint-plugin-jsx-a11y\": \"^3.0.2\", \"eslint-plugin-react\": \"^6.9.0\" &#125; 123npm install eslint --saveeslint -veslint --init 1npm install eslint-config-airbnb --save 1npm install eslint-plugin-import --save 1npm install eslint-plugin-jsx-a11y --save 1npm install eslint-plugin-react --save .eslintrc.js1234567module.exports = &#123; \"extends\": \"airbnb\", //使用airbnb前端编码规范 \"installedESLint\": true, \"rules\": &#123; \"indent\": [\"error\", 4] //缩进4个空格 &#125;&#125;;","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://YongMaple.github.io/categories/工具使用/"}],"tags":[{"name":"Atom","slug":"Atom","permalink":"http://YongMaple.github.io/tags/Atom/"},{"name":"eslint","slug":"eslint","permalink":"http://YongMaple.github.io/tags/eslint/"}]},{"title":"带数字字符串排序","slug":"带数字字符串排序","date":"2017-01-17T08:35:25.000Z","updated":"2017-01-17T09:00:50.000Z","comments":true,"path":"2017/01/17/带数字字符串排序/","link":"","permalink":"http://YongMaple.github.io/2017/01/17/带数字字符串排序/","excerpt":"","text":"今天组里在Q群发了一个问题：为一个给定字符串排序，这个字符串里的每一个单词都包含一个数字，请按数字大小给这些单词排序。 例如：is2 Thi1s T4est 3a 的结果是 Thi1s is2 3a T4est然后出现了3种解题：123456789101112var a = 'is2 Thi1s T4est 3a'var newArr = a.split(' ').map(function(item)&#123; console.log(item) var arr = item.match(/\\d+/) return arr&#125;)var str = newArr.sort(function(a,b)&#123;return +a[0] &gt; +b[0]&#125;).map(function(item)&#123;return item['input']&#125;).join(' ')console.log(str) 将原字符串用’ ‘分割成数组，然后遍历，返回由match后生成的数组组成的数组将新的数组按照match数组第0个元素（匹配正则的数字）排序，然后遍历返回match数组input元素（原来的String），最后拼接成字符串123456789101112var words = 'is2 Thi1s T4est 3a'function orderNew(words)&#123; var ordered = []; var arr = words.split(' '); arr.forEach(function(item, index)&#123; var match = /\\d+/.exec(item); ordered[parseInt(match[0])] = item; &#125;); return ordered.join(' ');&#125;console.log(orderNew(words)); 同样的将原字符串用’ ‘分割成数组，然后遍历遍历时将原数组元素放入新数组第[macth数组第0个元素（匹配正则的数字）]个元素最后将新数组拼接成字符串因为是数字排序，所有将找到的数据当成索引用，但是可能存在问题，如果有重复数字时，会覆盖掉1234567var words = 'is2 Thi1s T4est 3a'function order(words)&#123; return words.split(' ').sort(function(a, b)&#123; return a.match(/\\d+/) - b.match(/\\d+/); &#125;).join(' ');&#125;console.log(order(words)); 更加简化，将原字符串分割后直接按照数组元素匹配正则后的结果排序后，拼接","categories":[{"name":"编程思考","slug":"编程思考","permalink":"http://YongMaple.github.io/categories/编程思考/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://YongMaple.github.io/tags/排序/"}]},{"title":"关于Vue生命周期的一些理解记录","slug":"关于Vue生命周期的一些理解记录","date":"2017-01-17T08:34:06.000Z","updated":"2017-01-17T09:01:06.000Z","comments":true,"path":"2017/01/17/关于Vue生命周期的一些理解记录/","link":"","permalink":"http://YongMaple.github.io/2017/01/17/关于Vue生命周期的一些理解记录/","excerpt":"","text":"今天遇到个问题，大致是这样的：从父组件向子组件传值，第三层数据终端报错undefined，先上测试代码： 12345678910111213141516171819202122232425262728293031323334//父组件&lt;template lang=\"html\"&gt; &lt;div&gt; &lt;son :data=\"data1\"&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from '../son/index.vue'export default &#123; data()&#123; return &#123; data1:&#123;&#125; &#125; &#125;, mounted()&#123; this.data1=&#123; name:'最外层', value1:&#123; name:'第一层', value2:&#123; name:'第二层', value3:&#123; name:'第三层' &#125; &#125; &#125; &#125; &#125;, components:&#123; Son &#125;&#125;&lt;/script&gt; 12345678910111213141516171819202122232425//子组件&lt;template lang=\"html\"&gt; &lt;div&gt; 最外层 &#123;&#123;data.name&#125;&#125; &lt;div&gt; 第一层 &#123;&#123;data.value1.name&#125;&#125; &lt;div&gt; 第二层 &#123;&#123;data.value1.value2.name&#125;&#125; &lt;div&gt; 第三层 &#123;&#123;data.value1.value2.value3.name&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['data']&#125;&lt;/script&gt; 解决办法是将mounted中的赋值过程，改在beforeMount或者created中进行。或者先给data一个空的数据结构。原因是子组件渲染时，data的赋值还没进行，所以属性都是undefined","categories":[{"name":"Vue笔记","slug":"Vue笔记","permalink":"http://YongMaple.github.io/categories/Vue笔记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://YongMaple.github.io/tags/Vue/"}]},{"title":"扩展运算符(…)结合的使用","slug":"扩展运算符-…-结合的使用","date":"2017-01-17T08:32:23.000Z","updated":"2017-01-17T09:01:11.000Z","comments":true,"path":"2017/01/17/扩展运算符-…-结合的使用/","link":"","permalink":"http://YongMaple.github.io/2017/01/17/扩展运算符-…-结合的使用/","excerpt":"","text":"引入mapActions1import &#123; mapActions, mapGetters &#125; from 'vuex' 在methods中写123...mapActions([ 'SET_MAIL_LIST']), 数组中的所有方法会被引入，在使用时只要1this.SET_MAIL_LIST(&#123;mailList&#125;)","categories":[{"name":"Vue笔记","slug":"Vue笔记","permalink":"http://YongMaple.github.io/categories/Vue笔记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://YongMaple.github.io/tags/Vue/"}]},{"title":"Mac拼音输入法","slug":"Mac拼音输入法","date":"2017-01-17T08:30:47.000Z","updated":"2017-02-04T07:39:16.000Z","comments":true,"path":"2017/01/17/Mac拼音输入法/","link":"","permalink":"http://YongMaple.github.io/2017/01/17/Mac拼音输入法/","excerpt":"","text":"中英文切换mac自身输入法：Command＋空格 汉字输入切换下一页（用鼠标去点，太low了吧）假如你输入的文字不再第一页，这是需要我们切换页，上一页，是键盘上的“［”，下一页是键盘上的“］”。mac自身的输入法，也可以使用上下箭头来操作，但是，总是要低头找这个箭头，不方便。 输入特殊符号如果你记住了某个特殊字符的快捷键，那么，你只需使用 shift+option+键盘上的任何字符，来输入。如：shift+option+p是符号：∏当然，所有特殊符号都记住，是不可能的事情 ，所以，你也可以调出mac的特殊符号集，快捷键是control+coomand+空格，快去试试看，找到你想要的","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://YongMaple.github.io/categories/工具使用/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://YongMaple.github.io/tags/开发工具/"},{"name":"Mac","slug":"Mac","permalink":"http://YongMaple.github.io/tags/Mac/"},{"name":"输入法","slug":"输入法","permalink":"http://YongMaple.github.io/tags/输入法/"}]},{"title":"Atom已安装package记录","slug":"Atom已安装package记录","date":"2017-01-17T07:36:13.000Z","updated":"2017-02-04T06:59:56.000Z","comments":true,"path":"2017/01/17/Atom已安装package记录/","link":"","permalink":"http://YongMaple.github.io/2017/01/17/Atom已安装package记录/","excerpt":"","text":"platformio-ide-terminal 命令行工具快捷键：control+`呼出 activate-power-mode 炫酷的打字特效 atom-beautify 美化、整理代码 atom-ctags 强化版的自动完成，借助于autocomplete-plus atom-ternjs JS代码智能提示 autocomplete-paths 文件路径智能提示 color-picker 颜色拾取器快捷键：commod+shift+c docblockr 代码注释自动生成 file-icons 文件图标 git-plus git插件 highlight-selected 选中高亮 language-vue 识别Vue linter 代码校验基础工具 linter-csslint 校验css linter-eslint 校验js，配合.eslintrc使用 linter-sass-lint 校验sass minimap 右边小地图 minimap-find-and-replace 在小地图上显示搜索匹配 minimap-highlight-selected 在小地图上显示选中的 pigments 根据色值直接显示颜色 simplified-chinese-menu 中文汉化包 vue-autocomplete Vue自动完成","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://YongMaple.github.io/categories/工具使用/"}],"tags":[{"name":"Atom","slug":"Atom","permalink":"http://YongMaple.github.io/tags/Atom/"},{"name":"开发工具","slug":"开发工具","permalink":"http://YongMaple.github.io/tags/开发工具/"},{"name":"配置","slug":"配置","permalink":"http://YongMaple.github.io/tags/配置/"}]}]}